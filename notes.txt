// STATE = > IS AN INTERNAL OBJECT OF A COMPONENT
// IT IS USED TO STORE DATA THAT CAN CHANGE OVER TIME OR IN RESPONSE TO USER ACTIONS
// WHEN STATE CHANGES, THE COMPONENT RE-RENDERS TO REFLECT THE UPDATED DATA
// usestate return an array with two elements, a value and a function to update that value

//event handlers
// onclick = { increment }  // this is an event handler
// onscroll = { handleScroll }  // this is an event handler
// onchange = { handleChange }  // this is an event handler

// Hooks =>> functions, that are used to copy the lifecycle methods of class components, state management, and other features.


// RE RENDERING
// when a component re renders, it means that the component is being re-evaluated and
// its output is being updated based on changes in state or props
// when a component re renders, react compares the new output with the previous output

// FOLDER STRUCTURE 
// public =>> index.html, assets like images, fonts, icons
// src =>> all the code files, components, styles, utils, services, hooks
// node_modules =>> all the dependencies and packages
// package.json =>> all the metadata about the project, scripts, dependencies
// vite.config.js =>> configuration file for vite


// VITE VS CRA
// VITE IS A BUILD TOOL THAT PROVIDES A FAST DEVELOPMENT ENVIRONMENT FOR MODERN WEB
// APPLICATIONS. IT USES ES MODULES AND BROWSER NATIVE IMPORTS TO PROVID

// NPM VS NPX VS YARN
// NPM =>> NODE PACKAGE MANAGER, IT IS USED TO MANAGE THE DEPEND
// NPX =>> NODE PACKAGE EXECUTOR, IT IS USED TO EXECUTE THE PACKAGES
// YARN =>> YET ANOTHER RESOURCE NEGOTIATOR, IT IS USED TO


// STRICT MODE
// STRICT MODE IS A TOOL FOR IDENTIFYING POTENTIAL PROBLEMS IN AN APPLICATION
// IT ACTIVATES ADDITIONAL CHECKS AND WARNINGS FOR ITS DESCENDANTS


// JSX =>> JAVASCRIPT XML, IT IS A SYNTAX EXTENSION FOR JAVASCRIPT


// USESTATE
// IT IS A HOOK THAT ALLOWS YOU TO ADD STATE TO FUNCTION COMPONENTS


// VARIABLES VS STATE
// VARIABLES ARE USED TO STORE DATA THAT DOES NOT CHANGE OVER TIME
// STATE IS USED TO STORE DATA THAT CAN CHANGE OVER TIME OR IN RESPONSE TO USER ACTIONS
// WHEN STATE CHANGES, THE COMPONENT RE-RENDERS TO REFLECT THE UPDATED DATA

// FUNCTION REUSE IN REACT
// you can reuse functions in react by defining them outside the componeNT or if we want to use them in a same compoenent we can define them before the return statement




props,  Routes and Routing, Basic Form handling with state. 



// we use react router dom for routing in react

// Absolute Link=> this is for complete new routes or apps >
// Relative Link = > this is for relative to the application /profile

// conditional rendering => this is for rendering components based on certain conditions WE USE ? (ternary) FOR CONDITIONS

// React Router Dom => it is used for routing in react js
//Browser Router
// Routes,Route, Link
// path=> used to define the route path
// element = > used to store the element where we want to go
// to=> navigate to specfic route path




// state management
// api calls
//response mapping
// we don't prefer multiple states variables in a single component for better management
// we prefer to use single state variable in a single component regarding forms
// we can use object or array as a single state variable

// let obj = {
//     name: "Shivansh",
//     age: 21,
//     email: "shivansh@navgurukul.org"
// }

//  we can access the values of the object using dot notation or bracket notation

// IN CONTEXT OF REACT  REACT IS AN OBJECT
// IF you want to use useState without having to import it you can use React.useState


//props=> properties

// this is a the simulated version of useState
// function useState(props) {
//     return [props, function () { }]
// }

// All hooks are functions
// useState is a hook which is used to manage the state of a component
// useState returns an array of two elements
// first element is the current state, second element is a function which is used to update the state



// PROPS
// props are used to pass data from parent component to child component
// In react data flows in a unnidirectional way, parent to child
// props are read only, we cannot modify the props in the child component

// States are mutable, we can modify the state using the setState function
// props are immutable, we cannot modify the props in the child component, in parent we can modify the props and pass it to the child component again




// lifecycle OF REACT COMPONENTS 
1. Mounting => when the component is being created and inserted into the DOM
2. Updating => when the component is being re-rendered due to changes in state or props
3. Unmounting => when the component is being removed from the DOM


//SUBPHASES OF THE STAGES   => Lifecycle methods 

//componentwillmount=> phase before mounting
----------------//componentdidmount=> phase after mounting
//componentwillupdate=> phase before updating
 ---------------//componentdidupdate=> phase after updating
----------------//componentwillunmount=> phase before unmounting


we use useEffect to copy the side effects of the class components.
like we use usestate to copy the state management of the class components




// useeffect. this replaces component did mount, component did update, component will unmount
// useeffect is a hook which takes two parameters. first is a function and second is a dependency array

// USE EFFECT TAKES 2 PARAMETERS
// 1. FUNCTION
// 2. DEPENDENCY ARRAY

// component lifecycle in react
// three phases of lifecycle
// 1. Mounting - when the component is being inserted into the DOM
// 2. Updating - when the component is being re-rendered as a result of changes to either its props or state
// 3. Unmounting - when the component is being removed from the DOM

//component did mount > we check if the component is mounted or not
// component did update > we check if the component is updated or not
// component will unmount > we check if the component is unmounted or not



// component did mount => useeffect with empty dependency array
// component did update => useeffect with dependency array having some state variable
// component will unmount => useeffect with return function and empty dependency array
// we use return function in useeffect to clean up the component before it is unmounted
//by default useeffect does not return anything. if we want to return something we have to use return statement



// ALL API CALLS ARE MADE IN USEEFFECT HOOK
// WE ALWAYS DECLARE USEEFFECT AT THE TOP OF THE COMPONENT




  // hooks are functions.  useeffect takes 2 arguments.
  // function, dependency array.
  // useeffect does not return anything.

  // dependency array: to store the dependencies of useeffect.

  // component did mount is denoted with an empty dependency array. it stores the state on which the useeffect is dependent on running. IT MEANS THAT WHEN THE COMPONENT IS MOUNTED ONLY THEN THE FUNCTON WILL RUN.

  // FIRST TIME RENDER  WITH EMPTY DEPENDENCY ARRAY
  useEffect(() => { }, [])

  // component did update => i will basically store the state in the depdency array on which i want the use effect to run again and again.

  // EVERY TIME WHEN THE STATE IN THE DEPENDENCY ARRAY UPDATES.

  function dummy() {

    // for (let i = 0; i < 1000000000; i++) {
    //   // some dummy work
    // }
  }

  useEffect(dummy, [userId]);

  // component will unmount

  useEffect(() => {
    return () => {
      console.log("component will unmount")
    }
  }, []);


////////////////// JS EXECUTION CONTEXT ///////////////

    // async await ka simple rule > await keyword will only be used inside an async function.
    // both are keywords.
    //keywords=> reserved words in javascript, jinko tum aisi kahi pe istemal nahi kar sakte
    // async=> it makes a function asynchronous, yani ki wo function apne kaam ko background me chala sakta hai aur main thread ko block nahi karega.
    // await=> it makes a function wait for a promise to resolve, yani ki wo function tab tak wait karega jab tak promise resolve nahi hota.

    // execution context : where all the code is executed, an environment.
    // call stack:  it is a stack data structure that keeps track of the execution context of the code.


    // WEB API. SETINTERVAL=>0  console.log("1");
    // maan lo it is PROMISE console.log("2");
    // console.log("3");
    
    // 3,2,1 = > priority is always the syncronous operations  >>>>> promises or microtasks >>>>> macrotasks/callbacks 
    //EVENT LOOP = > IT MONITORS ALL THE QUEUES AND CALL STACK.
    // MICROTASK QUEUE => PROMISES, MUTATION OBSERVERS.
    // MACROTASK QUEUE/ CALLBACK QUEUE=> WEB APIS LIKE SETINTERVAL, SETTIMEOUT, BROWSER APIS
    syncronous operations=> LINE BY EXECUTE, JAVASCRIPT INBUILT OR WHICH ARE WRITTEN BY US. EXAMPLES> OPERATORS, FUNCTION CALLS, LOOPS, STATEMENTS.
